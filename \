#include "s4t-b.h"
#include <err.h>
#include <ctype.h>
#include <stdlib.h>
#include <limits.h>
#include <getopt.h>
#include <string.h>

static void print_usage (void);
static void parse_arguments (const uint32_t, char**, struct Program *const);

static void read_file (const char *const, struct SheetLexer *const);
static void calculate_sheet_dimensions (const char*, struct SheetDimensions *const);

static void lex_tables_content (struct Program *const);

int main (int argc, char **argv)
{
	if (argc == 1) print_usage();

	struct Program P;
	parse_arguments(argc, argv, &P);

	read_file(P.args.in_name, &P.slex);
	calculate_sheet_dimensions(P.slex.src, &P.sdim);

	P.grid = (struct Cell*) calloc(P.sdim.total_of_cells, sizeof(struct Cell));
	CHECK_PTR(P.grid);

	/* +---------------------------------------+
	 * +    |    |    |    |    |    |    |  *.|
	 * +---------------------------------------` Top right cell
	 * +    |    |    |    |    |    |    |    |
	 * +---------------------------------------+
	 * Clone operations (^) cannot be performed before this cell.
	 */
	P.sdim.toprightcell = &P.grid[P.sdim.rows - 1];

	free(P.slex.src);
	return 0;
}

static void print_usage (void)
{
	static const char* usage = "\tspreadsheet for terminal basic version - %s %s\n"
							   "\tusage: s4t-b [-s sheet] [arguments]\n"
							   "\targuments:\n"
							   "\t  -o <*>		write output to <*>\n"
							   "\t  -p <*>		decimal precision of <*>\n";
	fprintf(stderr, usage, __DATE__, __TIME__);
	exit(EXIT_SUCCESS);
}

static void parse_arguments (const uint32_t nargs, char **vargs, struct Program *const P)
{
	memset(P, 0, sizeof(struct Program));

	int32_t op;
	opterr = 0;

	while ((op = getopt(nargs, vargs, ":s:o:p:")) != -1) {
		switch (op) {
			case 's': P->args.in_name = optarg; break;
			case 'o': P->args.out_name = optarg; break;
			case 'p': P->args.precision = (int8_t) atoi(optarg); break;
			case ':': errx(EXIT_FAILURE, "[fatal]: the '-%c' option requires an argument", optopt); break;
			case '?': errx(EXIT_FAILURE, "[fatal]: the '-%c' option is unknown", optopt); break;
			default:  print_usage();
		}
	}

	if (!P->args.in_name)
		errx(EXIT_FAILURE, "[fatal]: cannot proceed without sheet.");

	if ((P->args.precision >= CHAR_MAX) || (P->args.precision <= 0))
		P->args.precision = 1;
}

static void read_file (const char *const filename, struct SheetLexer *const slex)
{
	FILE *sheet = fopen(filename, "r");
	if (!sheet)
		err(EXIT_FAILURE, "[fatal]: %s won't work due to", filename);

	fseek(sheet, 0, SEEK_END);
	slex->srcsz = ftell(sheet);
	fseek(sheet, 0, SEEK_SET);

	slex->src = (char*) calloc(slex->srcsz + 1, sizeof(char));
	CHECK_PTR(slex->src);

	const size_t read = fread(slex->src, 1, slex->srcsz, sheet);
	if (read != slex->srcsz)
		errx(EXIT_FAILURE, "[fatal]: not all file was read: %ld/%ld bytes", read, slex->srcsz);
	fclose(sheet);
}

static void calculate_sheet_dimensions (const char *src, struct SheetDimensions *const sdim)
{
	uint16_t columns = 0;

	while (*src) {
		const char a = *src++;
		if (a == '\n') {
			sdim->rows++;
			columns = MAX_OF(columns, sdim->columns);
			sdim->columns = 0;
		} else if (a == '|') sdim->columns++;
	}

	sdim->columns = columns;
	sdim->total_of_cells = (uint32_t) (sdim->columns * sdim->rows);
}


static void lex_tables_content (struct Program *const P)
{
	struct Token stream[TOKEN_CONTAINTER_LEN];
	memset(&stream, 0, sizeof(struct Token) * TOKEN_CONTAINTER_LEN);

	struct Cell  *ths_cell = &P->grid[0];
	struct Token *ths_tokn = &stream[0];
}
